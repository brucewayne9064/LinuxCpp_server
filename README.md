# linux cpp 网络编程学习

参考书为：linux c/c++服务器开发实践 朱文伟

## Ch3：多线程基本编程

进程是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位**，线程是进程的子任务，是**CPU调度和分派的基本单位**

### 一、利用POSIX多线程API进行多线程开发

利用POSIX多线程API进行多线程开发，需要使用一套定义了创建和操纵线程的函数，这些函数通常被称为Pthreads。Pthreads可以在Unix-like POSIX系统上运行，如Linux和Solaris

- Pthreads API中的函数可以非正式的划分为三大类： 
  1. **线程管理（Thread management）**: 第一类函数直接用于线程：创建（creating），分离（detaching），连接（joining）等等。包含了用于设置和查询线程属性（可连接，调度属性等）的函数。 
  2. **互斥量（Mutexes）**: 第二类函数是用于线程同步的，称为互斥量（mutexes），是"mutual exclusion"的缩写。Mutex函数提供了创建，销毁，锁定和解锁互斥量的功能。同时还包括了一些用于设定或修改互斥量属性的函数。 
  3. **条件变量（Condition variables）**：第三类函数处理共享一个互斥量的线程间的通信，基于程序员指定的条件。这类函数包括指定的条件变量的创建，销毁，等待和受信（signal）。设置查询条件变量属性的函数也包含其中。 

### 二、C++11中的线程类

### 三、线程同步

现代计算机操作系统的四大基本特性：并发，共享，虚拟，异步。

- 并发：**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指同一时刻能运行多个指令。单核处理器可以通过交替运行实现并发，多核处理器可以直接实现并行，但是操作系统也提供并发
- 共享：系统中的资源可供内存中多个并发执行的进程(线程)共同使用，包括互斥共享和同时共享
- 虚拟：把一个物理实体转换为多个逻辑实体
- 异步：进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进

***

- 线程同步：并发和异步机制带来了线程间资源竞争的无序性，需要同步来实现线程间正确有序的共享数据，以一致的顺序执行一组操作
- 临界资源：指一次仅允许一个线程使用的共享资源
- 临界区：每个线程中访问临界资源的代码段
- 原子操作：不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换（切换到另一个线程）。原子操作可以保证数据的一致性和安全性，避免竞争和死锁的问题。原子操作通常依赖于硬件平台提供的特殊指令来实现

### 四、基于POSIX的线程同步

互斥锁：可以通过互斥锁来同步线程访问临界资源

读写锁：提供了比互斥锁更好的并行性（并行性好不代表速度更快），以读模式加锁后，当多个线程试图以读模式加锁时，不会造成 这些线程阻塞在等待锁的释放。写模式则是独占的

条件变量：让一个线程因等待“条件变量的条件”而挂起，另外一个线程在条件成立后，立即向挂起的线程发送条件成立的信号

***

- 生产者消费者问题（producer-consumer）

  也叫做有界缓冲区问题（bounded buffer），没有条件变量可能出现死锁的问题。

***

**Pthread_cond_wait函数**：

`pthread_cond_wait`函数是一个用于在条件变量上阻塞当前线程的函数，它需要和互斥锁配合使用。它的作用是让当前线程A（阻塞并释放mutex）等待其他线程B通过`pthread_cond_signal`（唤醒一个）或`pthread_cond_broadcast`（唤醒全部）来唤醒它，从而实现线程间的同步。具体来说，他实现以下功能（其中第一步加第二步是原子操作）：

- 释放已掌握的互斥锁（解锁互斥量）相当于ptherad_mutex_unlock (&mutex);
- 阻塞等待条件变量cond
- 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock (&mutex);（也是一个原子操作）

```c++
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
```

其中，cond是一个指向条件变量的指针，mutex是一个指向互斥锁的指针。这个函数返回0表示成功，非0表示失败

### 五、C++11/14中的线程同步

- 基本互斥锁
- 定时互斥锁
- 递归互斥锁
- 定时递归互斥锁

### 六、线程池

线程池就是一种管理线程的工具，它维护了一定数量的线程，可以重复利用已创建的线程来执行任务，避免了频繁地创建和销毁线程。这样可以降低资源消耗，提高响应速度，增加线程的可管理性。

一般来说，线程池有以下几个参数：

- 核心线程数：线程池中保持活跃的最小线程数，即使没有任务也不会被回收。
- 最大线程数：线程池中能够容纳的最大线程数，超过这个数量的任务会被拒绝。
- 任务队列：用于存放等待执行的任务的队列，可以有不同的实现方式，如数组、链表、同步队列等。
- 线程工厂：用于创建新线程的工厂类，可以自定义一些属性，如名称、优先级、守护状态等。
- 拒绝策略：当任务队列满了且达到最大线程数时，如何处理新来的任务，可以有不同的策略，如抛出异常、丢弃任务、阻塞调用者等。

---

流程如下：

- 当有新的任务提交时，首先判断当前线程池中的线程数是否小于核心数（corePoolSize），如果是，则创建一个新的线程来执行该任务，即使此时有空闲的线程。**（核心线程数是线程池中保持活跃的最小线程数，即使没有任务也不会被回收，所以如果当前活跃线程数小于核心线程数，说明还有核心线程没有创建出来，所以需要创建一个新的核心线程来执行任务。如果当前活跃线程数等于或大于核心线程数，则说明所有的核心线程都已经创建出来了，此时就可以用一个空闲的核心线程或非核心线程来执行任务。）**
- 如果当前线程数已经达到核心数，那么就判断任务队列（workQueue）是否已经满了，如果没有，则将该任务放入队列中，等待被空闲的线程取出执行。
- 如果任务队列已经满了，那么就判断当前线程数是否小于最大数（maximumPoolSize），如果是，则创建一个新的线程来执行该任务。**（线程池的设计是为了提高任务的执行效率和资源的利用率。如果任务队列已满，说明当前的任务量很大，而且可能还有新的任务提交。如果此时只使用空闲线程来执行任务，可能会导致任务等待时间过长，影响性能和用户体验。因此，线程池会创建新的线程来执行任务，直到达到最大线程数。）**
- 如果当前线程数已经达到最大数，那么就执行拒绝策略（RejectedExecutionHandler）来处理该任务，比如抛出异常、丢弃任务、阻塞调用者等。
- 当一个线程执行完一个任务后，它会变成空闲状态，并尝试从队列中取出头部的任务来执行。如果队列为空，则该线程会等待一段时间（keepAliveTime），如果超时还没有新的任务，则该线程会被回收。

```mermaid
graph LR
A[提交任务] --> B{线程数<核心数}
B -->|是| C[创建新线程执行]
B -->|否| D{队列已满}
D -->|是| E{线程数<最大数}
E -->|是| F[创建新线程执行]
E -->|否| G[拒绝策略处理]
D -->|否| H[将任务放入队列]
I[空闲线程] -.-> J{队列是否为空}
J -->|是| K[等待超时回收]
J -->|否| L[取出队列头任务执行]
```

3.8节线程池的例3.40，利用POSIX实现一个简单的线程池，这是该例的流程图：

```mermaid
graph LR
A[主函数] --> B(创建线程池)
B --> C(初始化将5个线程回调函数与5个线程id绑定)
C --> D(得到包含5个线程的线程池)
A --> E(创建任务对象)
E --> F(任务对象功能打印字符串, 休眠1到4s)
E --> G(向任务链添加10个任务对象)
G --> H(每个添加会向线程池发送线程唤醒信号)
H -.-> D
D -.-> I{线程不断检查任务链-互斥访问}
I --任务链为空且没有关闭信号--> J(进入休眠等待唤醒)
J -.-> I
I --有关闭信号--> K(销毁线程)
K -.-> I
I --其他情况--> L(取出任务链的一个任务并执行)
L -.-> I
A -.-> M{主函数每隔两秒检查任务链上的任务数量}
M --没有任务--> N(执行线程池销毁函数)
N --> O{是否有已销毁信号}
O --是--> P[结束主函数]
O --否--> Q(设置关闭信号, 向所有线程发送唤醒信号, 清除所有线程, 清除互斥变量和条件变量) 
Q --> R[返回已销毁信号]
R --> O
M --有任务--> M
```

## Ch4：TCP服务器编程

套接字编程包括tcp套接字编程，udp套接字编程，原始套接字编程

### 一、套接字基本概念

套接字是TCP/IP模型中应用层与传输层的中间抽象层，socket编程接口是应用层与传输层之间的编程接口

socket是一种“打开——读/写——关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接后，可以向自己文件写入内容供对方读取或者读取对方的内容，通信结束时关闭文件

### 二、网络程序的架构

- browser/server

- client/server (网络编程中使用的架构)

### 三、IP地址的格式转换

注意大小端问题

- IP地址的高低位：

  IP地址是一个32位的二进制数，通常分为四个字节，每个字节用一个十进制数表示，中间用点隔开。例如，127.0.0.1就是一个IP地址。IP地址可以分为网络部分和主机部分，不同的类别的IP地址有不同的划分方式。一般来说，网络部分在IP地址的高位字节中，主机部分在低位字节中。例如，对于A类地址，第一个字节是网络部分，后面三个字节是主机部分；对于B类地址，前两个字节是网络部分，后两个字节是主机部分。

- 高序字节：

  高序字节是指一个多字节数据中的最高有效位。例如，对于一个四字节的32位整数0x12345678，其高序字节是0x12，低序字节是0x78。

- 大小端：

  大小端是指数据在存储或者传输时的**字节顺序**，具体分为大端和小端。**大端是指将高序字节存储在起始地址**，**小端是指将低序字节存储在起始地址**。例如，对于一个由两个字节组成的16位整数0x1234，在内存中的存储方式如下：

  | 地址   | 大端 | 小端 |
  | :----- | :--- | :--- |
  | 0x1000 | 0x12 | 0x34 |
  | 0x1001 | 0x34 | 0x12 |

- 网络字节序：

  网络字节序是TCP/IP协议规定的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用**大端模式**，即数据的高位字节存放在内存的低地址处。

  `UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待`,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节

- 主机字节序：

  主机字节序是指某个给定系统所用的字节顺序，它与CPU设计有关，不同的CPU可能有不同的主机字节序。比如x86系列CPU都是小端模式，而Motorola 6800为大端模式。当不同主机字节序的计算机之间进行网络通信时，需要将发送方的主机字节序转换为网络字节序，然后将接收方的网络字节序转换为主机字节序。

- 点分十进制的IP地址是一种人类可读的表示方式，它并不涉及存储方式的问题。所以直接看是看不出来的

  判断本地是大端还是小端的一种方法是通过强制类型转换截断一个多字节数据，看看低地址处存放的是高位字节还是低位字节

  举例说明：

  ```c
  #include <stdio.h>
  
  int isBigEndian()
  {
      unsigned short test = 0x1234; // 00010010 00110100
      if (*((unsigned char *)&test) == 0x12) // 取低地址处的字节
          return 1; // 大端模式
      else
          return 0; // 小端模式
  }
  
  int main()
  {
      if (isBigEndian())
          printf("This machine is big endian.\n");
      else
          printf("This machine is little endian.\n");
      return 0;
  }
  ```

***

inet_addr,inet_ntoa,inet_aton这些函数都是用来在IP地址和整数之间进行转换的，但是有一些区别:

- inet_addr()**把一个点分十进制的IP地址转换成一个网络字节序**（大端的无符号整数），如果输入无效，返回INADDR_NONE（通常是-1）。
- inet_ntoa()**把一个网络字节序转换成一个点分隔的IP地址**
- inet_aton()**把一个点分隔的IP地址转换成一个网络字节序的二进制数据，并存储在inp指向的结构体中，**如果地址有效，返回非零值，否则返回零。

### 四、套接字的类型

原始套接字和标准套接字的区别在于原始套接字可以读写内核没有处理的IP数据报，而标准套接字只能读TCP或者UDP报文

- 流套接字（SOCK_STREAM）

  提供面向连接，可靠的数据传输（因为用了TCP协议）

- 数据报套接字（SOCK_DGRAM）

  提供无连接服务（因为用了UDP协议）

- 原始套接字（SOCK_RAW）

  原始套接字允许对较低层次的协议直接访问（IP,ICMP），常用于检验新的协议实现，或者访问现有服务中配置的新设备，或者用于网络监听

### 五、套接字地址

一个套接字代表通信的一端，每端有一个套接字地址（套接字的一个参数）

socket地址包括：IP地址（从网络中识别主机），端口信息（从主机中识别进程）

socket地址分为：通用socket地址，专用socket地址（自定义专属网络地址）

本地机器上的套接字里保存的套接字地址是对方的还是自己的，取决于套接字的类型和使用场景：

- 对于流套接字（SOCK_STREAM），通常需要建立连接，所以本地机器上的套接字里保存了对方的套接字地址（IP地址和端口号）
- 对于数据报套接字（SOCK_DGRAM），通常不需要建立连接，所以本地机器上的套接字里保存了自己的套接字地址（IP地址和端口号）

***

获取套接字地址：

- getsockname()：获取本地

- getpeername()：获取对端

本地产生套接字地址：

- 本地套接字通过bind函数获取地址
- 本地套接字没有绑定地址，但是通过connect函数和远程建立了连接，此时内核会分配一个地址给本地套接字

### 六、主机字节序和网络字节序

- htonl()将uint32_t主机字节序转换为网络字节序
- ntohl()将uint32_t网络字节序转换为主机字节序
- htons()将uint16_t主机字节序转换为网络字节序
- ntohs()将uint16_t网络字节序转换为主机字节序

### 七、协议族和地址族

Linux支持PF和AF，所以指定协议用PF（protocol family），指定地址用AF（address family）

### 八、TCP套接字编程的基本步骤

服务器端编程的七个步骤一般是：

- 创建一个套接字（socket函数），用于监听客户端的连接请求。
- 绑定一个本地地址和端口到套接字上（bind函数），用于标识服务器的身份。
- 将套接字设置为监听模式（listen函数），用于等待客户端的连接请求，该套接字变成**监听套接字**。
- 接受一个客户端的连接请求，返回一个新的套接字（accept函数），用于和客户端进行通信。
- 通过新的套接字，与客户端进行数据交换（send和recv）。关闭与客户端的通信套接字，结束本次会话（closesocket函数）。
- 监听套接字继续监听，等待其他客户端连接请求。
- 关闭监听套接字（closesocket函数），结束服务器程序。

客户端编程的四个步骤一般是：

- 创建一个套接字（socket函数），用于和服务器进行通信。
- 向服务器发出连接请求（connect函数）。
- 和服务器通信（send和recv）
- 关闭客户端，关闭套接字（closesocket）。

### 九、TCP套接字编程的相关函数

- 客户端程序一般不调用bind函数来绑定socket地址，而使用socket默认的地址，是因为客户端不需要确定自己的ip和端口，而是由内核根据路由表来选择一个合适的本地地址和临时端口。如果你尝试读取了新创建的socket，里面的ip是0.0.0.0，端口也是0，那么表示这个socket还没有被绑定到任何具体的地址和端口上。当你调用connect或listen函数时，内核会为这个socket分配一个本地地址和临时端口。你可以通过getsockname函数来获取这个分配后的地址和端口。
- 服务器程序为什么要调用bind函数，是因为服务器需要在一个固定的地址和端口上监听客户端的连接请求。如果服务器不调用bind函数，那么内核会为套接字随机分配一个地址和端口，这样客户端就不知道怎么连接到服务器了。而客户端不需要调用bind函数，是因为客户端是主动向服务器发起连接请求的，内核会为客户端套接字自动分配一个本地地址和临时端口。客户端只需要知道服务器的地址和端口，就可以使用connect函数来建立连接了。

### 十、简单的TCP套接字编程

